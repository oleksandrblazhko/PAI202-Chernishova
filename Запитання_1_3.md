## Запитання № 1.3 (2 бали) Наведіть фрагменти прикладів уразливого програмного коду, розглянувши розділ References to Advisories, Solutions, and Tools.

### CWE-295: неправильна перевірка сертифіката

#### Приклад 1 (мова: C): <br>
Цей код перевіряє сертифікат підключеного вузла <br>
(поганий код)

```cpp
if ((cert = SSL_get_peer_certificate(ssl)) && host)
foo=SSL_get_verify_result(ssl);
if ((X509_V_OK==foo) || X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN==foo))
// сертифікат виглядає добре, хосту можна довіряти

```



У цьому випадку, оскільки сертифікат самопідписаний, не було зовнішнього органу, який міг би підтвердити особу хоста. Програма може спілкуватися з іншою системою, яка підмінює хост, напр. шляхом отруєння кешу DNS або використання атаки Противник-посередині Adversary-in-the-Middle (AITM) для зміни трафіку від сервера до клієнта.

#### Приклад 2 (мова: C):<br>
Наступний код OpenSSL отримує сертифікат і перевіряє його. <br>
(поганий код)

```cpp 
cert = SSL_get_peer_certificate(ssl);
if (cert && (SSL_get_verify_result(ssl)==X509_V_OK)) {

// do secret things
}
```

Незважаючи на те, що крок «перевірити» повертає X509_V_OK, цей крок не включає перевірку загального імені (англ. Common name) на ім’я хоста. Тобто немає гарантії, що сертифікат підходить для потрібного хоста. З’єднання SSL могло бути встановлено зі зловмисним хостом, який надав дійсний сертифікат.

#### Приклад 3 (мова: C):<br>
Наступний код OpenSSL гарантує наявність сертифіката та дозволяє використовувати сертифікати, термін дії яких закінчився.<br>
(поганий код)

```cpp 
if (cert = SSL_get_peer(certificate(ssl)) {
foo=SSL_get_verify_result(ssl);
if ((X509_V_OK==foo) || (X509_V_ERR_CERT_HAS_EXPIRED==foo))
```

Якщо виклик SSL_get_verify_result() повертає X509_V_ERR_CERT_HAS_EXPIRED, це означає, що термін дії сертифіката минув. З часом зловмисники збільшують шанси скомпрометувати даний сертифікат.

#### Приклад 4 (мова: C):<br>
Наступний код OpenSSL гарантує наявність сертифіката перед продовженням виконання.<br>

```cpp 
if (cert = SSL_get_peer_certificate(ssl)) {
...
}

```
Оскільки цей код не використовує SSL_get_verify_results() для перевірки сертифіката, він може приймати сертифікати, які були відкликані (X509_V_ERR_CERT_REVOKED). Програмне забезпечення могло спілкуватися зі зловмисним хостом.

#### Приклад 5 (мова: C):<br>
Наступний код OpenSSL гарантує, що хост має сертифікат.<br>
(поганий код)

```cpp 
if (cert = SSL_get_peer_certificate(ssl)) {

// отримання сертифікату, хосту можна довіряти

//foo=SSL_get_verify_result(ssl);

//if (X509_V_OK==foo) ...
}
```
Зауважте, що код не викликає SSL_get_verify_result(ssl), що фактично вимикає етап підтвердження, який перевіряє сертифікат.


### CWE-297: неправильна перевірка сертифіката з невідповідністю хосту

#### Приклад 1 (мова: C): Наступний код OpenSSL отримує сертифікат і перевіряє його.<br>

```cpp 
cert = SSL_get_peer_certificate(ssl);
if (cert && (SSL_get_verify_result(ssl)==X509_V_OK)) {

// do secret things
}
```
Незважаючи на те, що крок «перевірити» повертає X509_V_OK, цей крок не включає перевірку загального імені на ім’я хоста. Тобто немає гарантії, що сертифікат підходить для потрібного хоста. З’єднання SSL могло бути встановлено зі зловмисним хостом, який надав дійсний сертифікат

